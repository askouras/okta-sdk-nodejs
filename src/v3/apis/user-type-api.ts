/* tslint:disable */
/* eslint-disable */
/**
 * Okta API
 * Allows customers to easily access the Okta API
 *
 * OpenAPI spec version: 2.10.0
 * Contact: devex-public@okta.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { UserType } from '../models';
import { Response } from 'node-fetch';
import OAuth = require('../../OAuth');
import Http = require('../../Http');
import ConfigLoader = require('../../config-loader');
import DefaultRequestExecutor = require('../../default-request-executor');
import { V2Configuration } from '../../configuration';
import { Configuration } from '../configuration';

const os = require('os');
const packageJson = require('../../../package.json');

const DEFAULT_USER_AGENT = `${packageJson.name}/${packageJson.version} node/${process.versions.node} ${os.platform()}/${os.release()}`;

const repoUrl = 'https://github.com/okta/okta-sdk-nodejs';


/**
 * UserTypeApi - request parameter creator
 * @export
 */
export const UserTypeApiRequestParamCreator = function (configuration?: Configuration & V2Configuration) {
  const configLoader = new ConfigLoader();
  const clientConfig = Object.assign({}, configuration);
  configLoader.applyDefaults();
  configLoader.apply({
    client: clientConfig || {}
  });

  const parsedConfig = configLoader.config;
  const requestExecutor = clientConfig.requestExecutor || new DefaultRequestExecutor();
  const errors = [];
  if (!parsedConfig.client.orgUrl) {
    errors.push('Okta Org URL not provided');
  }

  if (!parsedConfig.client.token && parsedConfig.client.authorizationMode !== 'PrivateKey') {
    errors.push('Okta API token not provided');
  }

  if (parsedConfig.client.authorizationMode === 'PrivateKey') {
    if (!parsedConfig.client.clientId) {
      errors.push('Okta Client ID not provided');
    }
    if (!parsedConfig.client.scopes) {
      errors.push('Scopes not provided');
    }
    if (!parsedConfig.client.privateKey) {
      errors.push('Private Key not provided');
    }
  } else if (parsedConfig.client.authorizationMode !== 'SSWS') {
    errors.push('Unknown Authorization Mode');
  }
  if (errors.length) {
    throw new Error(`Found ${errors.length} errors:\n${errors.join('\n')}\nSee ${repoUrl} for usage.`);
  }
  const authorizationMode = parsedConfig.client.authorizationMode;
  const baseUrl = parsedConfig.client.orgUrl.replace(/\/$/, '');
  const apiToken = parsedConfig.client.token;

  let clientId;
  let scopes;
  let privateKey;
  let oauth;
  if (authorizationMode === 'PrivateKey') {
    clientId = parsedConfig.client.clientId;
    scopes = parsedConfig.client.scopes.split(' ');
    privateKey = parsedConfig.client.privateKey;
    oauth = new OAuth(this);
  }

  const httpClient = new Http({
    cacheStore: clientConfig.cacheStore,
    cacheMiddleware: clientConfig.cacheMiddleware,
    defaultCacheMiddlewareResponseBufferSize: clientConfig.defaultCacheMiddlewareResponseBufferSize,
    requestExecutor: requestExecutor,
    oauth: oauth
  });
  if (authorizationMode === 'SSWS') {
    httpClient.defaultHeaders.Authorization = `SSWS ${apiToken}`;
  }
  httpClient.defaultHeaders['User-Agent'] = parsedConfig.client.userAgent ? parsedConfig.client.userAgent + ' ' + DEFAULT_USER_AGENT : DEFAULT_USER_AGENT;

    return {
      httpClient,
        /**
         * Creates a new User Type. A default User Type is automatically created along with your org, and you may add another 9 User Types for a maximum of 10.
         * @summary Create User Type
         * @param {UserType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserType: async (body: UserType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createUserType.');
            }
            const localVarPath = `/api/v1/meta/types/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_token required
            if (configuration && configuration.apiToken) {
                const localVarApiKeyValue = typeof configuration.apiToken === 'function'
                    ? await configuration.apiToken("Authorization")
                    : await configuration.apiToken;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["okta.apps.read", "okta.apps.manage", "okta.authenticators.read", "okta.authenticators.manage", "okta.authorizationServers.read", "okta.authorizationServers.manage", "okta.brands.read", "okta.brands.manage", "okta.captchas.manage", "okta.captchas.read", "okta.domains.read", "okta.domains.manage", "okta.eventHooks.read", "okta.eventHooks.manage", "okta.groups.read", "okta.groups.manage", "okta.roles.read", "okta.roles.manage", "okta.idps.read", "okta.idps.manage", "okta.users.manage", "okta.inlineHooks.read", "okta.inlineHooks.manage", "okta.logs.read", "okta.profileMappings.read", "okta.profileMappings.manage", "okta.schemas.read", "okta.schemas.manage", "okta.linkedObjects.read", "okta.linkedObjects.manage", "okta.userTypes.read", "okta.userTypes.manage", "okta.orgs.read", "okta.orgs.manage", "okta.policies.read", "okta.policies.manage", "okta.sessions.read", "okta.sessions.manage", "okta.templates.read", "okta.templates.manage", "okta.trustedOrigins.read", "okta.trustedOrigins.manage", "okta.users.read.self", "okta.users.read"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a User Type permanently. This operation is not permitted for the default type, nor for any User Type that has existing users
         * @summary Delete User Type
         * @param {string} typeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserType: async (typeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeId' is not null or undefined
            if (typeId === null || typeId === undefined) {
                throw new RequiredError('typeId','Required parameter typeId was null or undefined when calling deleteUserType.');
            }
            const localVarPath = `/api/v1/meta/types/user/{typeId}`
                .replace(`{${"typeId"}}`, encodeURIComponent(String(typeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_token required
            if (configuration && configuration.apiToken) {
                const localVarApiKeyValue = typeof configuration.apiToken === 'function'
                    ? await configuration.apiToken("Authorization")
                    : await configuration.apiToken;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["okta.apps.read", "okta.apps.manage", "okta.authenticators.read", "okta.authenticators.manage", "okta.authorizationServers.read", "okta.authorizationServers.manage", "okta.brands.read", "okta.brands.manage", "okta.captchas.manage", "okta.captchas.read", "okta.domains.read", "okta.domains.manage", "okta.eventHooks.read", "okta.eventHooks.manage", "okta.groups.read", "okta.groups.manage", "okta.roles.read", "okta.roles.manage", "okta.idps.read", "okta.idps.manage", "okta.users.manage", "okta.inlineHooks.read", "okta.inlineHooks.manage", "okta.logs.read", "okta.profileMappings.read", "okta.profileMappings.manage", "okta.schemas.read", "okta.schemas.manage", "okta.linkedObjects.read", "okta.linkedObjects.manage", "okta.userTypes.read", "okta.userTypes.manage", "okta.orgs.read", "okta.orgs.manage", "okta.policies.read", "okta.policies.manage", "okta.sessions.read", "okta.sessions.manage", "okta.templates.read", "okta.templates.manage", "okta.trustedOrigins.read", "okta.trustedOrigins.manage", "okta.users.read.self", "okta.users.read"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a User Type by ID. The special identifier `default` may be used to fetch the default User Type.
         * @summary Get User Type
         * @param {string} typeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserType: async (typeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeId' is not null or undefined
            if (typeId === null || typeId === undefined) {
                throw new RequiredError('typeId','Required parameter typeId was null or undefined when calling getUserType.');
            }
            const localVarPath = `/api/v1/meta/types/user/{typeId}`
                .replace(`{${"typeId"}}`, encodeURIComponent(String(typeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_token required
            if (configuration && configuration.apiToken) {
                const localVarApiKeyValue = typeof configuration.apiToken === 'function'
                    ? await configuration.apiToken("Authorization")
                    : await configuration.apiToken;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["okta.apps.read", "okta.apps.manage", "okta.authenticators.read", "okta.authenticators.manage", "okta.authorizationServers.read", "okta.authorizationServers.manage", "okta.brands.read", "okta.brands.manage", "okta.captchas.manage", "okta.captchas.read", "okta.domains.read", "okta.domains.manage", "okta.eventHooks.read", "okta.eventHooks.manage", "okta.groups.read", "okta.groups.manage", "okta.roles.read", "okta.roles.manage", "okta.idps.read", "okta.idps.manage", "okta.users.manage", "okta.inlineHooks.read", "okta.inlineHooks.manage", "okta.logs.read", "okta.profileMappings.read", "okta.profileMappings.manage", "okta.schemas.read", "okta.schemas.manage", "okta.linkedObjects.read", "okta.linkedObjects.manage", "okta.userTypes.read", "okta.userTypes.manage", "okta.orgs.read", "okta.orgs.manage", "okta.policies.read", "okta.policies.manage", "okta.sessions.read", "okta.sessions.manage", "okta.templates.read", "okta.templates.manage", "okta.trustedOrigins.read", "okta.trustedOrigins.manage", "okta.users.read.self", "okta.users.read"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all User Types in your org
         * @summary List User Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/meta/types/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_token required
            if (configuration && configuration.apiToken) {
                const localVarApiKeyValue = typeof configuration.apiToken === 'function'
                    ? await configuration.apiToken("Authorization")
                    : await configuration.apiToken;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["okta.apps.read", "okta.apps.manage", "okta.authenticators.read", "okta.authenticators.manage", "okta.authorizationServers.read", "okta.authorizationServers.manage", "okta.brands.read", "okta.brands.manage", "okta.captchas.manage", "okta.captchas.read", "okta.domains.read", "okta.domains.manage", "okta.eventHooks.read", "okta.eventHooks.manage", "okta.groups.read", "okta.groups.manage", "okta.roles.read", "okta.roles.manage", "okta.idps.read", "okta.idps.manage", "okta.users.manage", "okta.inlineHooks.read", "okta.inlineHooks.manage", "okta.logs.read", "okta.profileMappings.read", "okta.profileMappings.manage", "okta.schemas.read", "okta.schemas.manage", "okta.linkedObjects.read", "okta.linkedObjects.manage", "okta.userTypes.read", "okta.userTypes.manage", "okta.orgs.read", "okta.orgs.manage", "okta.policies.read", "okta.policies.manage", "okta.sessions.read", "okta.sessions.manage", "okta.templates.read", "okta.templates.manage", "okta.trustedOrigins.read", "okta.trustedOrigins.manage", "okta.users.read.self", "okta.users.read"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace an existing User Type
         * @summary Replace User Type
         * @param {UserType} body 
         * @param {string} typeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceUserType: async (body: UserType, typeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling replaceUserType.');
            }
            // verify required parameter 'typeId' is not null or undefined
            if (typeId === null || typeId === undefined) {
                throw new RequiredError('typeId','Required parameter typeId was null or undefined when calling replaceUserType.');
            }
            const localVarPath = `/api/v1/meta/types/user/{typeId}`
                .replace(`{${"typeId"}}`, encodeURIComponent(String(typeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_token required
            if (configuration && configuration.apiToken) {
                const localVarApiKeyValue = typeof configuration.apiToken === 'function'
                    ? await configuration.apiToken("Authorization")
                    : await configuration.apiToken;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["okta.apps.read", "okta.apps.manage", "okta.authenticators.read", "okta.authenticators.manage", "okta.authorizationServers.read", "okta.authorizationServers.manage", "okta.brands.read", "okta.brands.manage", "okta.captchas.manage", "okta.captchas.read", "okta.domains.read", "okta.domains.manage", "okta.eventHooks.read", "okta.eventHooks.manage", "okta.groups.read", "okta.groups.manage", "okta.roles.read", "okta.roles.manage", "okta.idps.read", "okta.idps.manage", "okta.users.manage", "okta.inlineHooks.read", "okta.inlineHooks.manage", "okta.logs.read", "okta.profileMappings.read", "okta.profileMappings.manage", "okta.schemas.read", "okta.schemas.manage", "okta.linkedObjects.read", "okta.linkedObjects.manage", "okta.userTypes.read", "okta.userTypes.manage", "okta.orgs.read", "okta.orgs.manage", "okta.policies.read", "okta.policies.manage", "okta.sessions.read", "okta.sessions.manage", "okta.templates.read", "okta.templates.manage", "okta.trustedOrigins.read", "okta.trustedOrigins.manage", "okta.users.read.self", "okta.users.read"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing User Type
         * @summary Update User Type
         * @param {UserType} body 
         * @param {string} typeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserType: async (body: UserType, typeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUserType.');
            }
            // verify required parameter 'typeId' is not null or undefined
            if (typeId === null || typeId === undefined) {
                throw new RequiredError('typeId','Required parameter typeId was null or undefined when calling updateUserType.');
            }
            const localVarPath = `/api/v1/meta/types/user/{typeId}`
                .replace(`{${"typeId"}}`, encodeURIComponent(String(typeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_token required
            if (configuration && configuration.apiToken) {
                const localVarApiKeyValue = typeof configuration.apiToken === 'function'
                    ? await configuration.apiToken("Authorization")
                    : await configuration.apiToken;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", ["okta.apps.read", "okta.apps.manage", "okta.authenticators.read", "okta.authenticators.manage", "okta.authorizationServers.read", "okta.authorizationServers.manage", "okta.brands.read", "okta.brands.manage", "okta.captchas.manage", "okta.captchas.read", "okta.domains.read", "okta.domains.manage", "okta.eventHooks.read", "okta.eventHooks.manage", "okta.groups.read", "okta.groups.manage", "okta.roles.read", "okta.roles.manage", "okta.idps.read", "okta.idps.manage", "okta.users.manage", "okta.inlineHooks.read", "okta.inlineHooks.manage", "okta.logs.read", "okta.profileMappings.read", "okta.profileMappings.manage", "okta.schemas.read", "okta.schemas.manage", "okta.linkedObjects.read", "okta.linkedObjects.manage", "okta.userTypes.read", "okta.userTypes.manage", "okta.orgs.read", "okta.orgs.manage", "okta.policies.read", "okta.policies.manage", "okta.sessions.read", "okta.sessions.manage", "okta.templates.read", "okta.templates.manage", "okta.trustedOrigins.read", "okta.trustedOrigins.manage", "okta.users.read.self", "okta.users.read"])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserTypeApi - functional programming interface
 * @export
 */
export const UserTypeApiFp = function(configuration?: Configuration & V2Configuration) {
    return {
        /**
         * Creates a new User Type. A default User Type is automatically created along with your org, and you may add another 9 User Types for a maximum of 10.
         * @summary Create User Type
         * @param {UserType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserType(body: UserType, options?: any): Promise<(httpClient?: Http, basePath?: string) => Promise<UserType>> {
            const api = UserTypeApiRequestParamCreator(configuration);
            const localVarRequestArgs = await api.createUserType(body, options);
            return (httpClient: Http = api.httpClient, basePath: string = configuration.basePath || configuration.orgUrl) => {
              const requestArgs = {...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url};
              
              return httpClient.http(requestArgs.url, requestArgs).then(res => res.json()) as Promise<UserType>;
            }
        },
        /**
         * Deletes a User Type permanently. This operation is not permitted for the default type, nor for any User Type that has existing users
         * @summary Delete User Type
         * @param {string} typeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserType(typeId: string, options?: any): Promise<(httpClient?: Http, basePath?: string) => Promise<Response>> {
            const api = UserTypeApiRequestParamCreator(configuration);
            const localVarRequestArgs = await api.deleteUserType(typeId, options);
            return (httpClient: Http = api.httpClient, basePath: string = configuration.basePath || configuration.orgUrl) => {
              const requestArgs = {...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url};
              
              return httpClient.http(requestArgs.url, requestArgs) as Promise<Response>;
            }
        },
        /**
         * Fetches a User Type by ID. The special identifier `default` may be used to fetch the default User Type.
         * @summary Get User Type
         * @param {string} typeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserType(typeId: string, options?: any): Promise<(httpClient?: Http, basePath?: string) => Promise<UserType>> {
            const api = UserTypeApiRequestParamCreator(configuration);
            const localVarRequestArgs = await api.getUserType(typeId, options);
            return (httpClient: Http = api.httpClient, basePath: string = configuration.basePath || configuration.orgUrl) => {
              const requestArgs = {...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url};
              
              return httpClient.http(requestArgs.url, requestArgs).then(res => res.json()) as Promise<UserType>;
            }
        },
        /**
         * Fetches all User Types in your org
         * @summary List User Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserTypes(options?: any): Promise<(httpClient?: Http, basePath?: string) => Promise<Array<UserType>>> {
            const api = UserTypeApiRequestParamCreator(configuration);
            const localVarRequestArgs = await api.listUserTypes(options);
            return (httpClient: Http = api.httpClient, basePath: string = configuration.basePath || configuration.orgUrl) => {
              const requestArgs = {...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url};
              
              return httpClient.http(requestArgs.url, requestArgs).then(res => res.json()) as Promise<Array<UserType>>;
            }
        },
        /**
         * Replace an existing User Type
         * @summary Replace User Type
         * @param {UserType} body 
         * @param {string} typeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceUserType(body: UserType, typeId: string, options?: any): Promise<(httpClient?: Http, basePath?: string) => Promise<UserType>> {
            const api = UserTypeApiRequestParamCreator(configuration);
            const localVarRequestArgs = await api.replaceUserType(body, typeId, options);
            return (httpClient: Http = api.httpClient, basePath: string = configuration.basePath || configuration.orgUrl) => {
              const requestArgs = {...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url};
              
              return httpClient.http(requestArgs.url, requestArgs).then(res => res.json()) as Promise<UserType>;
            }
        },
        /**
         * Updates an existing User Type
         * @summary Update User Type
         * @param {UserType} body 
         * @param {string} typeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserType(body: UserType, typeId: string, options?: any): Promise<(httpClient?: Http, basePath?: string) => Promise<UserType>> {
            const api = UserTypeApiRequestParamCreator(configuration);
            const localVarRequestArgs = await api.updateUserType(body, typeId, options);
            return (httpClient: Http = api.httpClient, basePath: string = configuration.basePath || configuration.orgUrl) => {
              const requestArgs = {...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url};
              
              return httpClient.http(requestArgs.url, requestArgs).then(res => res.json()) as Promise<UserType>;
            }
        },
    }
};

/**
 * UserTypeApi - factory interface
 * @export
 */
export const UserTypeApiFactory = function (configuration?: Configuration, basePath?: string, httpClient?: Http) {
    return {
        /**
         * Creates a new User Type. A default User Type is automatically created along with your org, and you may add another 9 User Types for a maximum of 10.
         * @summary Create User Type
         * @param {UserType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserType(body: UserType, options?: any): Promise<UserType> {
            return UserTypeApiFp(configuration).createUserType(body, options).then((request) => request(httpClient, basePath));
        },
        /**
         * Deletes a User Type permanently. This operation is not permitted for the default type, nor for any User Type that has existing users
         * @summary Delete User Type
         * @param {string} typeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserType(typeId: string, options?: any): Promise<Response> {
            return UserTypeApiFp(configuration).deleteUserType(typeId, options).then((request) => request(httpClient, basePath));
        },
        /**
         * Fetches a User Type by ID. The special identifier `default` may be used to fetch the default User Type.
         * @summary Get User Type
         * @param {string} typeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserType(typeId: string, options?: any): Promise<UserType> {
            return UserTypeApiFp(configuration).getUserType(typeId, options).then((request) => request(httpClient, basePath));
        },
        /**
         * Fetches all User Types in your org
         * @summary List User Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserTypes(options?: any): Promise<Array<UserType>> {
            return UserTypeApiFp(configuration).listUserTypes(options).then((request) => request(httpClient, basePath));
        },
        /**
         * Replace an existing User Type
         * @summary Replace User Type
         * @param {UserType} body 
         * @param {string} typeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceUserType(body: UserType, typeId: string, options?: any): Promise<UserType> {
            return UserTypeApiFp(configuration).replaceUserType(body, typeId, options).then((request) => request(httpClient, basePath));
        },
        /**
         * Updates an existing User Type
         * @summary Update User Type
         * @param {UserType} body 
         * @param {string} typeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserType(body: UserType, typeId: string, options?: any): Promise<UserType> {
            return UserTypeApiFp(configuration).updateUserType(body, typeId, options).then((request) => request(httpClient, basePath));
        },
    };
};

/**
 * UserTypeApi - object-oriented interface
 * @export
 * @class UserTypeApi
 * @extends {BaseAPI}
 */
export class UserTypeApi extends BaseAPI {
    /**
     * Creates a new User Type. A default User Type is automatically created along with your org, and you may add another 9 User Types for a maximum of 10.
     * @summary Create User Type
     * @param {UserType} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTypeApi
     */
    public createUserType(body: UserType, options?: any) {
        const api = UserTypeApiRequestParamCreator(this.configuration);
        return UserTypeApiFp(this.configuration).createUserType(body, options).then((request) => request(api.httpClient, this.basePath));
    }
    /**
     * Deletes a User Type permanently. This operation is not permitted for the default type, nor for any User Type that has existing users
     * @summary Delete User Type
     * @param {string} typeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTypeApi
     */
    public deleteUserType(typeId: string, options?: any) {
        const api = UserTypeApiRequestParamCreator(this.configuration);
        return UserTypeApiFp(this.configuration).deleteUserType(typeId, options).then((request) => request(api.httpClient, this.basePath));
    }
    /**
     * Fetches a User Type by ID. The special identifier `default` may be used to fetch the default User Type.
     * @summary Get User Type
     * @param {string} typeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTypeApi
     */
    public getUserType(typeId: string, options?: any) {
        const api = UserTypeApiRequestParamCreator(this.configuration);
        return UserTypeApiFp(this.configuration).getUserType(typeId, options).then((request) => request(api.httpClient, this.basePath));
    }
    /**
     * Fetches all User Types in your org
     * @summary List User Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTypeApi
     */
    public listUserTypes(options?: any) {
        const api = UserTypeApiRequestParamCreator(this.configuration);
        return UserTypeApiFp(this.configuration).listUserTypes(options).then((request) => request(api.httpClient, this.basePath));
    }
    /**
     * Replace an existing User Type
     * @summary Replace User Type
     * @param {UserType} body 
     * @param {string} typeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTypeApi
     */
    public replaceUserType(body: UserType, typeId: string, options?: any) {
        const api = UserTypeApiRequestParamCreator(this.configuration);
        return UserTypeApiFp(this.configuration).replaceUserType(body, typeId, options).then((request) => request(api.httpClient, this.basePath));
    }
    /**
     * Updates an existing User Type
     * @summary Update User Type
     * @param {UserType} body 
     * @param {string} typeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTypeApi
     */
    public updateUserType(body: UserType, typeId: string, options?: any) {
        const api = UserTypeApiRequestParamCreator(this.configuration);
        return UserTypeApiFp(this.configuration).updateUserType(body, typeId, options).then((request) => request(api.httpClient, this.basePath));
    }
}
